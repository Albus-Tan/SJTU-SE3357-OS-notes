[TOC]

# 处理器调度

系统中的任务数远多于处理器数，怎么使用少量处理器运行很多任务（线程、单线程进程）？

## 进程\线程调度

<img src="cpu-sched 处理器调度.assets/image-20230314095930850.png" alt="image-20230314095930850" style="zoom: 20%;" />

调度器运行在每个CPU上

2) 执行该任务的CPU：涉及负载均衡

3) 执行时长（时间片长度）：编译时确定的 linux 中时间片有 1ms（desktop版本，响应速度快） 和 10ms（server）；执行时执行的时长还会在此基础上进行微调

## 调度：协调对资源的使用请求

对于不同场景，调度的主要目标不同：

- 批处理系统：高吞吐量
- 交互式系统：低响应时间
- 网络服务器：可扩展性
- 移动设备：低能耗
- 实时系统：实时性

**调度的共有目标：**

- **高资源利用率**
- **多任务公平性**
- **低调度开销**

调度器的目标：

- **降低周转时间：**任务第一次进入系统到执行结束的时间
- **降低响应时间：**任务第一次进入系统到第一次给用户输出的时间
- **实时性：**在任务的截止时间内完成任务
- **公平性：**每个任务都应该有机会执行，不能饿死
- **开销低：**调度器是为了优化系统，而非制造性能BUG
- **可扩展：**随着任务数量增加，仍能正常工作

调度的挑战：

- 缺少信息（没有**先知**）
  - 工作场景动态变化
- 线程/任务间的复杂交互
- 调度目标多样性
  - 不同的系统可能关注不一样的调度指标
- 许多方面存在取舍
  - 调度开销 V.S. 调度效果
  - 优先级 V.S. 公平
  - 能耗 V.S. 性能

## 调度指标

**周转时间：**任务第一次进入系统到执行结束的时间（进入到退出）

**响应时间：**任务第一次进入系统到第一次给用户输出的时间（进入到响应/任务开始被执行，响应时不一定退出）

公平性，实时性，开销，可扩展

## 经典调度 Classical Scheduling

### First Come First Served（FCFS）

先到先得

**问题：**平均周转、响应时间过长

### Shortest Job First（SJF）

短任务优先

**优势：**平均周转时间短

**问题：**

1）不公平，任务饿死

2）平均响应时间过长

3)  依赖对于任务的先验知识（预知任务执行时间）

### 抢占式调度 Preemptive Scheduling

每次任务执行一定时间后会被切换到下一任务，而非执行至终止（通过定时触发的时钟中断实现）

### 时间片轮转 Round Robin（RR）

每次任务执行一定时间后会被切换到下一任务，每个任务时间片一致

**轮询：**公平、平均响应时间短

**问题：**牺牲周转时间

对于交互式要求很高的场景合适

**什么情况下RR的周转时间问题最为明显？**

如果每个任务的执行时间差不多相同

**时间片长短应该如何确定？**

时间片过长的话，RR会退化为FCFS

时间片过短的话，在真实场景中调度开销会变大

## 优先级调度 Priority Scheduling

操作系统中的任务重要性是不同的（系统/用户，前台/后台......），优先级用于确保重要的任务被优先调度

### 多级队列 Multi-Level Queue (MLQ)

1）维护多个队列，每个对应静态设置好的优先级（如 I/O 密集型和 CPU 密集型）

2）高优先级的任务优先执行

3）同优先级内使用Round Robin调度（也可使用其他调度策略）

依赖对于任务的先验知识，需要预知任务是否为I/O密集型任务

### 优先级的选取

**问题1：低资源利用率，多种资源（如CPU和I/O）没有同时利用起来**

有些任务是 I/O intensive，需要去访问磁盘，这类任务一开始的时候用一下CPU，之后就开始等硬盘；CPU希望能先调用 I/O intensive 的任务，在这些任务等待磁盘的时候，就可以服务那些别的 CPU intensive 的任务；否则如果先 CPU intensive 任务，I/O 就没有被利用起来，闲置。

**问题2：优先级反转（高、低优先级任务都需要独占共享资源，低优先任务占用资源 -> 高优先级任务被阻塞）**

独占通过信号量，互斥锁等实现

<img src="cpu-sched 处理器调度.assets/image-20230314104416753.png" alt="image-20230314104416753" style="zoom:15%;" />

A 与 C 都需要独占某一共享资源，但是此时 C 在执行，那么高优先级的 A 抢占 C 时会因为共享资源被 C 占用而失败；但是此时如果优先级在 A 与 C 之间的 B 进场，由于 B 与 C 之间没有共享资源的冲突，同时 B 的优先级比 C 高，B 就能抢占成功开始执行，形成 B 优先于 A 执行的局面（但是 A 优先级高于 B）

<img src="cpu-sched 处理器调度.assets/image-20230314104522293.png" alt="image-20230314104522293" style="zoom:15%;" />

A 把自己的优先级暂时给到 C，这样 B 就抢占不了了（这样 B 优先级会比 C 低）

**什么样的任务应该有高优先级？**

- I/O绑定的任务：有些任务是 I/O intensive，需要去访问磁盘，这类任务一开始的时候用一下CPU，之后就开始等硬盘；CPU希望能先调用 I/O intensive 的任务，在这些任务等待磁盘的时候，就可以服务那些别的 CPU intensive 的任务
  - 为了更高的资源利用率
- 用户主动设置的重要任务
- 时延要求极高（必须在短时间内完成）的任务
- 等待时间过长的任务
  - 为了公平性

**广义层面的优先级调度**

本质上FCFS的优先级是任务的到达顺序，SJF的优先级是任务的完成时间短，RR则没有优先级概念（或者说所有任务优先级相同）

> linux 中优先级体现为 nice（+20 到 -20）：越nice（值越大），优先级越低

## 多级反馈队列 Multi-Level Feedback Queue（MLFQ）

静态优先级的问题：低优先级任务饥饿（被高优先级任务阻塞，长时间无法执行）

**实现任务优先级的动态调整**（操作系统中的工作场景是动态变化的）

无需先验知识，通过动态分析任务运行历史，总结任务特征（但是如果工作场景变化频繁，效果会很差）

### 基本算法

**规则 1：**优先级高的任务会抢占优先级低的任务（同MLQ）

**规则 2：**每个任务会被分配时间片，优先级相同的两个任务使用时间片轮转（同MLQ）

**规则 3：**任务被创建时，**假设该任务是短任务**（用一点CPU就会主动放掉的），为它分配最高优先级

**规则 4a：**一个任务时间片耗尽后，它的优先级会被降低一级

**规则 4b：**如果一个任务在时间片耗尽前放弃CPU，那么它的优先级不变；任务重新执行时，会被分配新的时间片

- 对于长任务：MLFQ会逐渐降低它的优先级，并将它视为长任务
- 对于短任务：它会很快执行完
- 对于I/O密集型任务：它会在时间片执行完以前放弃CPU，MLFQ保持它的优先级不变即可

<img src="cpu-sched 处理器调度.assets/image-20230314110631508.png" alt="image-20230314110631508" style="zoom:15%;" />

#### **基本算法的问题**

- 长任务饥饿：过多的短任务、I/O密集型任务可能占用所有CPU时间
- 任务特征可能动态变化：CPU密集型任务变成交互式任务，…
- 无法应对抢占CPU时间的攻击

##### **定时优先级提升（解决长任务饥饿和任务特征动态变化方案）**

**规则 5:** <u>在某个时间段S后，将系统中所有任务优先级升为最高</u>

- 效果1：避免长任务饿死
  - 所有任务的优先级会定时地提升最高
  - 最高级队列采用RR，长任务一定会被调度到
- 效果2：针对任务特征动态变化的场景
  - MLFQ会定时地重新审视每个任务

<img src="cpu-sched 处理器调度.assets/image-20230314110940511.png" alt="image-20230314110940511" style="zoom:15%;" />

**为什么要提升全部的优先级，而不随机挑选几个提升？**

万一有的任务运气不好，一直没有被提升（需要保证随机算法覆盖到所有任务，复杂性高）

##### **更准确地记录执行时间（应对抢占CPU时间的攻击）**

- 恶意任务在时间片用完前发起I/O请求
- 避免MLFQ将该任务的优先级降低，并且每次重新执行时间片会被重置
  - 几乎独占CPU！

**规则** **4:** <u>一个任务时间片耗尽后（无论它期间放弃了多次CPU，它的时间片不会被重置），它的优先级会被降低一级</u>

**更新策略**

- 记录每个任务在当前优先级使用的时间片
- 当累计一个完整时间片被用完后，降低其优先级

### 参数调试

- 优先级队列的数量
- 不同队列的时间片长短应当不同（时间片最高优先级应该短，最低优先级应该长）
- 定时优先级提升的时间间隔

### 总结

- 通过观察任务的历史执行，动态确定任务优先级
  - 无需任务的先验知识
- 同时达到了周转时间和响应时间两方面的要求
  - 对于短任务，周转时间指标近似于SJF
  - 对于交互式任务，响应时间指标近似于RR
- 可以避免长任务的饿死
- 许多著名系统的调度器是基于MLFQ实现的，如BSD, Solaris, Windows NT 和后续Windows操作系统

## 公平共享调度 Fair-Share Scheduling

### ticket

方法：使用“ticket”表示任务的份额

ticket：每个任务对应的份额

T ：ticket的总量

> 任务A：ticket 20，任务B：ticket 30，任务C：ticket 50，则A:B:C占用的CPU执行时间 20:30:50

### 彩票调度（Lottery Scheduling）

<img src="cpu-sched 处理器调度.assets/image-20230314112222356.png" alt="image-20230314112222356" style="zoom:15%;" />

原理就是调度T次时（时间足够长），每个任务被调度次数的期望 == 该任务的份额

> 伪随机！可能会出现不可控情况，即短时间内某一任务持续被调度，别的任务短时间内starvation

### 步幅调度（Stride Scheduling）

将 ticket 转换为 stride（先找所有 ticket 的最小公倍数 MaxStride，再用这个数除以每个 ticket 得到 stride）

<img src="cpu-sched 处理器调度.assets/image-20230314112730688.png" alt="image-20230314112730688" style="zoom:15%;" />

<img src="cpu-sched 处理器调度.assets/image-20230314112916106.png" alt="image-20230314112916106" style="zoom:15%;" />

stride 就相当于“虚拟”的时间，每次挑累计执行的虚拟时间（累计 stride）最少的跑

每个任务跑，怎么样都不会差太多

### 比较

|                              | **Lottery**  **Scheduling** | **Stride**   **Scheduling** |
| ---------------------------- | --------------------------- | --------------------------- |
| 调度决策生成                 | 随机                        | 确定性计算                  |
| 任务实际执行时间与预期的差距 | 大                          | 小                          |

## 份额 与 优先级 的异同?

- 份额影响任务对CPU的占用比例
  - 不会有任务饿死
- 优先级影响任务对CPU的使用顺序
  - 可能产生饿死

导致饿死就是不公平，不导致饿死就是公平！

## 多核调度策略 Multicore Scheduling Policy

多核调度需要考虑的额外因素：一个进程的不同线程可以在不同CPU上同时运行

### 群组调度 Gang Scheduling

- 同一个进程的不同线程倾向于让他们同时跑！（同一个进程内的所有线程可能有依赖关系，可能会等所有线程都执行完才能执行下一步，如GCC编译，每个线程编译一个文件 .c 到 .o，所有线程把 .o 生成完之后才能进行下一步操作）
- 组内任务都是关联任务，希望尽可能同时执行

### 全局使用一个调度器的问题

- 所有CPU竞争全局调度器（以及其数据结构）
- 同一个线程可能在不同CPU上切换
  - 切换开销大：Cache、TLB、…
  - 缓存局部性差

### 两层调度 Two-level Scheduling

<img src="cpu-sched 处理器调度.assets/image-20230314113515842.png" alt="image-20230314113515842" style="zoom:15%;" />

- 全局调度器把一些线程放到各个CPU上

- 之后每个CPU上有本地调度器（每个CPU核心都有自己的 runq），负责调度自己被分配的这些线程

- 一段时间后，再回到全局调度器

问题：资源调度一定是越全局掌控越好，全局才可能带来资源最大的利用率（信息最多）

### 负载均衡（Load Balance）

其中一个CPU被分配的线程都跑完了，另一个却还在跑

- 需要追踪CPU的负载情况
- 将任务从负载高的CPU核心迁移到负载低的CPU核心（work stealing）

work stealing 就会导致某个 CPU 核上的 runq 有可能被另外两个 CPU 核心同时访问（两个人都去抢同一个任务），引发同步问题，需要加锁

#### 如何定义任务的负载

根据任务负载定义的不同，负载均衡的效果也不尽相同

- 每个CPU核心本地运行队列的长度
  - 优势：实现简单
  - 劣势：不能准确反应当前CPU的负载情况
- 每个任务单位时间内使用的CPU资源
  - 优势：直观反映当前CPU的负载情况
  - 劣势：引入额外负载追踪开销

### 亲和性（Affinity）

允许程序员把线程绑定到某一个核心上（`sched_setaffinity`，`sched_getaffinity`）

**程序员如何控制自己程序的行为？**例如，程序员希望某个线程独占一个CPU核心

**通过操作系统暴露的任务亲和性接口，可以指定任务能够使用的CPU核心**

